//import { Injectable } from '@nestjs/common';
import { AuthService } from 'src/auth/auth.service';
import { Injectable, Inject, forwardRef } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { User } from './user.entity';
import { Repository } from 'typeorm';
import { CreateUserDto } from './dtos/create-user.dto';
import { Profile } from 'src/profile/profile.entity';

@Injectable()
export class UsersService {
  constructor(
    @Inject(forwardRef(() => AuthService))
    private readonly authService: AuthService,
    @InjectRepository(User)
    private userRepository: Repository<User>,

    // inorder to create a user with profile we need to inject the ProfileRepository here
    @InjectRepository(Profile)
    private profileRepository: Repository<Profile>,
  ) {}

  async getAllUsers() {
    console.log('Getting all users');
    return await this.userRepository.find();
  }

  async getUserByEmail(email: string) {
    console.log(email);
    return await this.userRepository.findOne({ where: { email } });
  }

  // note by for the profile id which is the primary key that is a foreign key in the user entity
  // we do not need to provide it when creating a user with profile
  // as it will be automatically generated by the database
  // when we create a profile first and then use that profile to create a user
  // this is because of the one-to-one relationship between user and profile
  // and also because of the cascade option that we have set in the user entity
  // so when we create a user with profile, the profile will be created first
  // and then the user will be created with the profile id that was generated
  // when the profile was created
  public async createUser(user: CreateUserDto) {
    // create a profile entity only if user.profile is not null
    user.profile = user.profile ?? {}; // in this case either we have a value or null
    let profile = this.profileRepository.create(user.profile);
    // save the profile in the database
    profile = await this.profileRepository.save(profile);

    // create a user entity

    //  It uses object destructuring to remove the profile property from the user object.
    //  profile: _ extracts the profile property and assigns it to _ (which is unused).
    //  ...userWithoutProfile collects the rest of the properties into a new object called userWithoutProfile.
    //  This way, userWithoutProfile contains all properties of user except profile.
    const { profile: _, ...userWithoutProfile } = user;
    const newUser = this.userRepository.create(userWithoutProfile);
    // set the profile of the user to the profile that we just created
    newUser.profile = profile;

    // hash the password, you can hash a password from here
    //newUser.password = await this.authService.hashPassword(user.password);

    // save the user in the database
    await this.userRepository.save(newUser);
    return `User with Email ${newUser.email} created successfully with profile id ${profile.id}`;
  }

  /*
  async getUsersByMaritalStatus(isMarried?: boolean) {
    if (isMarried === undefined) {
      return await this.userRepository.find();
    }
    return await this.userRepository.find({
      where: { isMarried },
    });
  }
  */

  // getUsersByAge(age: number) {
  //   return this.users.filter((user) => user.age === age);
  // }

  async updateUser(user: {
    firstname?: string;
    lastname?: string;
    age?: number;
    isMarried?: boolean;
    password?: string;
    email?: string;
  }) {
    // find user by email
    const existingUser = await this.userRepository.findOne({
      where: { email: user.email },
    });
    if (existingUser) {
      // Update only the provided fields
      Object.assign(existingUser, user);
    } else {
      return `User with Email ${user.email} not found.`;
    }

    // save the updated user to the database
    await this.userRepository.save(existingUser);
    return `User with Email ${user.email} updated successfully: ${JSON.stringify(existingUser)}`;
  }
}

/**
 * Potential causes:
- A circular dependency between modules. Use forwardRef() to avoid it. Read more: https://docs.nestjs.com/fundamentals/circular-dependency
- The module at index [0] is of type "undefined". Check your import statements and the type of the module.
 */
